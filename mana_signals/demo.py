# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/50_demo.ipynb.

# %% auto 0
__all__ = ['RVolCalculator', 'RMarketVol', 'ExecEngine', 'SignalEngine', 'SignalEngineLive', 'simulate_signal_processing']

# %% ../nbs/50_demo.ipynb 3
from .core import *
from .reactive import *
from .data import *
import numpy as np
from typing import List
from pathlib import Path
import argparse


# %% ../nbs/50_demo.ipynb 4
class RVolCalculator(RValue): 
    """
    Vol calculator for given price input.

    Calculates vol of last 20 price ticks for a given input.
    """
    def __init__(self, priceInput: RValue):
        super().__init__()
        self.last_trades = RLastn(priceInput, n=20)
    def calc(self): return np.std(np.log1p(self.last_trades.value))

# %% ../nbs/50_demo.ipynb 5
class RMarketVol(RValue): 
    """
    calculates average volatility of the given price inputs
    """
    def __init__(self,symbol_prices: List[RValue]):
        super().__init__()
        self.deps = [RVolCalculator(v) for v in symbol_prices]
    def calc(self): 
        vols = np.array([d.value for d in self.deps])
        return np.nanmean(vols)

# %% ../nbs/50_demo.ipynb 6
class ExecEngine():
    """Execution engine for the market"""
    def load_all_market_data_files(self, directory: Path):
        syms = get_symbols(directory)
        frames = [load_symbol(directory, sym) for sym in syms]
        self.market_data = make_sequential_stream(frames)

    def load_market_data_files(self, files: List[Path]): 
        frames = [load_market_data_file(file) for file in files]
        self.market_data = make_sequential_stream(frames)

    def run(self): 
        "Runs the engine by feeding market data to the system"
        for ts, row in self.market_data.iterrows():
            self.process(ts, row)
    def process(self, ts, row): raise NotImplementedError('Override engine process function')
        
        

# %% ../nbs/50_demo.ipynb 11
class SignalEngine(ExecEngine):
    def __init__(self): 
        super().__init__()
        self.market_price_inputs = {
            'MATICUSDT': RInput(np.nan),
            'OP': RInput(np.nan),
            'XRP': RInput(np.nan)
        }
        self.market_vol = RMarketVol(self.market_price_inputs.values())
        self.result=[]

    def process(self, ts, row):
        input = self.market_price_inputs[row.symbol]
        input.set_value(row.price)
        self.output(f'{ts}, {self.market_vol.value}')

    def output(self, line): 
        self.result.append(line)
        
    

# %% ../nbs/50_demo.ipynb 18
class SignalEngineLive(SignalEngine):
    def output(self, line): print(line)

# %% ../nbs/50_demo.ipynb 20
def simulate_signal_processing():
    """Script entry point for signal processing"""
    parser = argparse.ArgumentParser(description='Simulate Signal Processing')
    parser.add_argument('data', type=str, help='input data file in csv format')
    args = parser.parse_args()
    engine = SignalEngineLive()
    engine.load_market_data_files([args.data])
    engine.run()

