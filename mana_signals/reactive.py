# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_reactive.ipynb.

# %% auto 0
__all__ = ['singleton_model', 'RModel', 'RValue', 'RInput', 'rcalc']

# %% ../nbs/10_reactive.ipynb 4
from fastcore.all import *
from nbdev import show_doc

# %% ../nbs/10_reactive.ipynb 7
class RModel(): 
    "Reactive model defines global calculation timer"
    ts: int # current time step of the calculation
    def __init__(self): self.ts = 0
    def step(self): 
        "Increases the timestep of the reactive model"
        self.ts += 1
    __repr__ = basic_repr('ts')
    

# %% ../nbs/10_reactive.ipynb 9
singleton_model = RModel() # Global singleton for model (used if not passed down to calculations)

# %% ../nbs/10_reactive.ipynb 12
class RValue():
    """Basic reactive calculation primitive

    The object represents a cachable reactive value. 

    Method `calc`() on an object is called whenever a value of the object is needed. 
    The value is cached in an object. 
    The value is automatically invalidated whenever its inputs changes.
    """
    __repr__ = basic_repr('cached_value,ts_checked,ts_updated,model')
    def __init__(self, model:RModel=singleton_model): 
        self.cached_value, self.ts_checked, self.ts_updated = (None, 0, 0)
        self.deps, self.model = None, model
    def set_model(self,model:RModel): 
        """Sets model for the calculated value. 
        Setting model also sets automatically model for all dependent values
        """
        self.model = model
        for v in self.get_dependents(): v.set_model(model)

    def invalidate_if_outdated(self): 
        if self.ts_checked < self.model.ts: 
            dep_ts = [v.invalidate_if_outdated() for v in self.get_dependents()]
            max_dep_ts = max(dep_ts) if dep_ts else 0
            if self.ts_updated < max_dep_ts: 
                self.ts_updated = max_dep_ts
                self.cached_value = None
            self.ts_checked = self.model.ts
        return self.ts_updated

    def is_outdated(self): 
        """Returns true if the value changed due to update to dependent inputs"""
        self.invalidate_if_outdated()
        return self.cached_value is None
        
    def get_dependents(self): 
        """Returns all RValues that this calculation depends on"""
        if self.deps is None: 
            self.deps = [ v for (n,v) in self.__dict__.items() if isinstance(v,RValue)]
        return self.deps
        
    @property
    def value(self): 
        """Returns value of the RValue object. 
        If the value is outdated, the calc method is automatically called
        """
        if self.model.ts > self.ts_checked :
            self.invalidate_if_outdated()
        if self.cached_value is None: self.cached_value = self.calc()
        return self.cached_value
  
    def calc(self): 
        """Calculates the value. Must be overriden"""
        raise NotImplementedError('RValue.calc method must be overriden')



# %% ../nbs/10_reactive.ipynb 17
class RInput(RValue):
    """
    Represents input value to the calculation

    Input values are `RValue`s that can be set using `RInput.set_value`.
    """
    def __init__(self, init_value): super().__init__(); self.cached_value = init_value
    def set_value(self, value): 
        """
        Sets the value of the RValue object. 
        Any other reactive values that depend on this value are automatically invalidated
        """
        self.model.step()
        self.ts_checked = self.ts_updated = self.model.ts
        self.cached_value = value
    def calc(self): raise NotImplementedError("Input value not provided")


# %% ../nbs/10_reactive.ipynb 27
def rcalc(func):
    """
    A decorator for converting a simple function to a reactive value
    """
    class RCalcClass(RValue):
        def __init__(self, *args):
            super().__init__()
          
            self.deps = args
            
        def calc(self):
            return func(*[a.value for a in self.deps])

    RCalcClass.__name__ = func.__name__.capitalize()
    return RCalcClass
