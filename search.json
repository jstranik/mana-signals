[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mana-signals",
    "section": "",
    "text": "A computational engine with reactive values for real-time processing of the data.",
    "crumbs": [
      "mana-signals"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "mana-signals",
    "section": "Install",
    "text": "Install\npip install git+https://github.com/jstranik/mana-signals.git",
    "crumbs": [
      "mana-signals"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "mana-signals",
    "section": "How to use",
    "text": "How to use\nThe package contains a library for processing market data and making signal generators.\nDocumentation of the library is avaialble at https://jstranik.github.io/mana-signals/reactive.html\nHowever here is a small teaser:\n\na = RInput(0)\nv = RLastn(a, 3)\nfor i in range(5): \n    print(v.value)\n    a.set_value(i)\n\n[ 0. nan nan]\n[ 0.  0. nan]\n[1. 0. 0.]\n[2. 1. 0.]\n[3. 2. 1.]\n\n\nAbove example shows a reactive primite RLastn which collect last 3 values of the data. The reactive values recalculate on demand when an input is change. Therefore accessing v.value mutliple times does not trigger recalculation unless a is changed.",
    "crumbs": [
      "mana-signals"
    ]
  },
  {
    "objectID": "index.html#demo-script",
    "href": "index.html#demo-script",
    "title": "mana-signals",
    "section": "Demo script",
    "text": "Demo script\nThe package contain a simple demo application (available in demo module) which processes market data and on every tick prints a mean market volatility across symbols.\nThe demo app can be invoked as:\n\n$&gt; simulate_signal_processing ../marketdata/20230601.MATIC.csv.gz\n\nThe application will print in realtime to the console actual market volatility on every market input.",
    "crumbs": [
      "mana-signals"
    ]
  },
  {
    "objectID": "performance.html",
    "href": "performance.html",
    "title": "performance",
    "section": "",
    "text": "Data\nDownload the data so that we have something to work with\n\n! ../scripts/download.sh\n\n\n!mv marketdata/ ..\n\n\n\nInline Signal Set Calculator\n\nimport numpy as np\n\nclass SignalSetCalculator:\n    def __init__(self):\n        self.lastTradePrice: float = np.nan\n        self.lastTradeAmount: float = np.nan\n        self.dTradePrice: float = 0.\n        self.dTradeAmount: float = 0.\n\n    def update(self, message: dict):\n        px = message['price']\n        amt = message['amount']\n\n        self.dTradePrice = px - self.lastTradePrice\n        self.dTradeAmount = amt - self.lastTradeAmount\n        self.lastTradePrice = px\n        self.lastTradeAmount = amt\n    \n    def get(self):\n        return np.array([\n            self.lastTradePrice, self.lastTradeAmount, self.dTradePrice, self.dTradeAmount,\n            ], dtype = np.float64)\n\n\n\nOps Driven Calculator\n\nimport numpy as np\n\nclass InputOp:\n    \"\"\" reads a message from the input \"\"\"\n    def __init__(self):\n        self.dtype = dict\n        self.value = {}\n        self.inputs = []\n\n    def update(self, message: dict):\n        self.value = message\n\nclass GetOp:\n    \"\"\" reads a field from the input message \"\"\"\n    def __init__(self, field: str, dtype: np.dtype, inputs: list):\n        self.field = field\n        self.dtype = dtype\n        self.value = dtype()\n        self.inputs = inputs\n\n    def update(self, message: dict):\n        self.value = self.dtype(message[self.field])\n\nclass DiffOp:\n    \"\"\" computes the difference between the current and last value \"\"\"\n    def __init__(self, dtype: np.dtype, inputs: list):\n        self.dtype = dtype\n        self.value = dtype()\n        self.last = dtype()\n        self.inputs = inputs\n    \n    def update(self, x):\n        self.value = x - self.last\n        self.last = x\n\nclass SignalSetCalculatorOps:\n    def __init__(self):\n        self.input = InputOp()\n        self.lastTradePrice = GetOp(\"price\", np.float64, [\"input\"])\n        self.lastTradeAmount = GetOp(\"amount\", np.float64, [\"input\"])\n        self.dTradePrice = DiffOp(np.float64, [\"lastTradePrice\"])\n        self.dTradeAmount = DiffOp(np.float64, [\"lastTradeAmount\"])\n\n    def updatesignal(self, signal):\n        signal.update(*[getattr(self, x).value for x in signal.inputs])\n\n    def update(self, message: dict):\n        self.input.update(message)\n        self.updatesignal(self.lastTradePrice)\n        self.updatesignal(self.lastTradeAmount)\n        self.updatesignal(self.dTradePrice)\n        self.updatesignal(self.dTradeAmount)\n\n    def get(self):\n        return np.array([\n            self.lastTradePrice.value, self.lastTradeAmount.value, self.dTradePrice.value, self.dTradeAmount.value,\n            ], dtype=np.float64)\n\n\n\nComparing the two approaches\nThey should produce same result. Want to see how fast they are as well.\n\nimport pandas as pd\nimport numpy as np\n\ndata=pd.read_csv(\"../marketdata/20231101.OP.csv.gz\", compression=\"gzip\"); data\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\n\n\n0\nbybit\nOPUSDT\n1698796801797000\n1698796801835449\n6487eaa4-ab7e-534d-b5a1-6d9ee482c8a4\nsell\n1.3961\n250.0\n\n\n1\nbybit\nOPUSDT\n1698796801804000\n1698796801842170\n7e7537e0-aba4-52f6-8636-90a78e1e035f\nsell\n1.3961\n150.0\n\n\n2\nbybit\nOPUSDT\n1698796801804000\n1698796801842170\nbd3dd448-527f-541a-99d9-161d9599d7d3\nsell\n1.3961\n11.7\n\n\n3\nbybit\nOPUSDT\n1698796806911000\n1698796806949468\nb40d10f4-1efd-5923-be61-308ab947d073\nsell\n1.3960\n115.6\n\n\n4\nbybit\nOPUSDT\n1698796809007000\n1698796809044363\n99bb5885-ff82-559d-88b0-c98cb538d1c2\nbuy\n1.3961\n22.2\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n136125\nbybit\nOPUSDT\n1698883190808000\n1698883190853743\nd93744d8-62b5-5d60-be9a-0e2efa12da2e\nbuy\n1.4379\n219.9\n\n\n136126\nbybit\nOPUSDT\n1698883190815000\n1698883190860478\n4e716785-0fa5-5ffc-be29-9a05e252d985\nbuy\n1.4379\n15.6\n\n\n136127\nbybit\nOPUSDT\n1698883190815000\n1698883190860478\nb4bc5d5b-4a83-5dcd-b20c-6e98f3943893\nbuy\n1.4379\n28.0\n\n\n136128\nbybit\nOPUSDT\n1698883190815000\n1698883190860478\n81536c25-4cca-545f-a440-137b296277dd\nbuy\n1.4379\n298.6\n\n\n136129\nbybit\nOPUSDT\n1698883192974000\n1698883193020791\n74e62133-399c-5a99-947c-5f67c1fbffe1\nbuy\n1.4380\n61.0\n\n\n\n\n136130 rows × 8 columns\n\n\n\n\n\ndef testSignalCalculator():\n    fc = SignalSetCalculator()\n    i=0\n    result1=[]\n    for row in data.to_dict(orient='records') :\n        i += 1\n        fc.update(row)\n        if i%1000 == 0: result1.append(fc.get())\n    return result1\n\n214 ms ± 1.17 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\n\ndef testSignalCalculatorOps():\n    fc = SignalSetCalculatorOps()\n    i=0\n    result=[]\n    for row in data.to_dict(orient='records') :\n        i += 1\n        fc.update(row)\n        if i%1000 == 0: result.append(fc.get())\n    return result\n\n381 ms ± 2.21 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n\n\nWe see that the later approach is about twice as slow. Is the slowness worth it?\n\ndef are_lists_of_arrays_close(list1, list2, rtol=1e-05, atol=1e-08):\n    if len(list1) != len(list2):\n        return False\n    for array1, array2 in zip(list1, list2):\n        if not np.allclose(array1, array2):\n            return False\n    return True\n\n\nare_lists_of_arrays_close(testSignalCalculator(), testSignalCalculatorOps())\n\nTrue\n\n\nBut at least both approaches are returning the same result :)\n\n\nAlternative - Using array calculations for backtesting\n\ndef testSignalCalculatorNumpy(): \n    d = data.copy()\n    d['dTradePrice'] = d.price.diff()\n    d['dTradeAmount'] = d.amount.diff()\n    result = d[['price','amount', 'dTradePrice', 'dTradeAmount']].iloc[999::1000]\n    return [row for row in result.to_numpy()]\n\n4.76 ms ± 113 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\nare_lists_of_arrays_close(testSignalCalculator(), testSignalCalculatorNumpy())\n\nTrue\n\n\nWe see that direct numpy vector operations are way faster than any iterative looping using python.\nAbout 50x faster than SignalSetCalculator() and about 100x faster than SignalSetCalculatorOps()\n\n\nConculsion\nFor back-testing, we nearly certainly want to use numpy for calculating signals.\n\n\nFaster Execution\n\n\n\nCollecting numba\n  Obtaining dependency information for numba from https://files.pythonhosted.org/packages/ef/20/94ef7b3afee76f47f3ad2d9dfc64f5cb29a365df00e5c563e7518e761bc0/numba-0.59.0-cp311-cp311-macosx_11_0_arm64.whl.metadata\n  Using cached numba-0.59.0-cp311-cp311-macosx_11_0_arm64.whl.metadata (2.7 kB)\nCollecting llvmlite&lt;0.43,&gt;=0.42.0dev0 (from numba)\n  Obtaining dependency information for llvmlite&lt;0.43,&gt;=0.42.0dev0 from https://files.pythonhosted.org/packages/ba/3a/286d01191e62ddbe645d4a3f1e0d96106a98d3fd7f82441d20ffe93ab669/llvmlite-0.42.0-cp311-cp311-macosx_11_0_arm64.whl.metadata\n  Using cached llvmlite-0.42.0-cp311-cp311-macosx_11_0_arm64.whl.metadata (4.8 kB)\nRequirement already satisfied: numpy&lt;1.27,&gt;=1.22 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from numba) (1.26.4)\nUsing cached numba-0.59.0-cp311-cp311-macosx_11_0_arm64.whl (2.6 MB)\nUsing cached llvmlite-0.42.0-cp311-cp311-macosx_11_0_arm64.whl (28.8 MB)\nInstalling collected packages: llvmlite, numba\nSuccessfully installed llvmlite-0.42.0 numba-0.59.0\n\n[notice] A new release of pip is available: 23.2.1 -&gt; 24.0\n[notice] To update, run: pip install --upgrade pip\nNote: you may need to restart the kernel to use updated packages.\n\n\n\nfrom numba import njit\n@njit\ndef testSignalCalculator2():\n    fc = SignalSetCalculator()\n    i=0\n    result1=[]\n    for row in data.to_dict(orient='records') :\n        i += 1\n        fc.update(row)\n        if i%1000 == 0: result1.append(fc.get())\n    return result1\n\nTypingError: Failed in nopython mode pipeline (step: nopython frontend)\nUntyped global name 'SignalSetCalculator': Cannot determine Numba type of &lt;class 'type'&gt;\n\nFile \"../../../../../../var/folders/l_/l7636tpj5zzd5cx3pwzdd8k00000gn/T/ipykernel_77153/98501214.py\", line 4:\n&lt;source missing, REPL/exec in use?&gt;\n\n\nAbove does not work since numba can only compile functions, not python classes.",
    "crumbs": [
      "performance"
    ]
  },
  {
    "objectID": "reactive.html",
    "href": "reactive.html",
    "title": "reactive",
    "section": "",
    "text": "We define basic abstractions for calculations\n\n\nTracks timesteps of the calculation.\nReactive values can use either the global singleton or a dedicated instance\n\nsource\n\n\n\n RModel ()\n\nReactive model defines global calculation timer\n\nsource\n\n\n\n\n RModel.step ()\n\nIncreases the timestep of the reactive model\nWe also have a global variable singleton_model to represent a global singleton.\n\n\n\n\n\nsource\n\n\n\n RValue (model:__main__.RModel=__main__.RModel(ts=0))\n\nBasic reactive calculation primitive\nThe object represents a cachable reactive value.\nMethod calc() on an object is called whenever a value of the object is needed. The value is cached in an object. The value is automatically invalidated whenever its inputs changes.\n\nsource\n\n\n\n\n RValue.get_dependents ()\n\nReturns all RValues that this calculation depends on\n\nsource\n\n\n\n\n RValue.value ()\n\nReturns value of the RValue object. If the value is outdated, the calc method is automatically called\n\nsource\n\n\n\n\n RValue.is_outdated ()\n\nReturns true if the value changed due to update to dependent inputs\n\nsource\n\n\n\n\n RValue.calc ()\n\nCalculates the value. Must be overriden\n\nsource\n\n\n\n\n RInput (init_value)\n\nRepresents input value to the calculation\nInput values are RValues that can be set using RInput.set_value.\n\nsource\n\n\n\n\n RInput.set_value (value)\n\nSets the value of the RValue object. Any other reactive values that depend on this value are automatically invalidated\n\n\n\n\n\n\nMost basic usage of reactive values. Here we create a reactive value with 2 inputs and calculate the result\n\na = RInput(1)\nb = RInput(2)\nclass RCalc(RValue):\n    def __init__(self,a,b): super().__init__(); self.a,self.b = a,b\n    def calc(self):\n        print(\"calculating value c\")\n        return self.a.value + self.b.value\nc= RCalc(a,b)\nc.value\n\ncalculating value c\n\n\n3\n\n\n\nc.value\n\n3\n\n\n\na.set_value(5)\n\n\nc.value\n\ncalculating value c\n\n\n7\n\n\n\n\n\nLet’s make writing calculated values a little bit easier.\n\nsource\n\n\n\n\n rcalc (func)\n\nA decorator for converting a simple function to a reactive value\n\na = RInput(1)\nb = RInput(2)\n\n@rcalc\ndef adder(a,b): return a+b\nc = adder(a,b)\nc.value\n\n3\n\n\n\na.set_value(7)\nc.value\n\n9",
    "crumbs": [
      "reactive"
    ]
  },
  {
    "objectID": "reactive.html#rmodel",
    "href": "reactive.html#rmodel",
    "title": "reactive",
    "section": "",
    "text": "Tracks timesteps of the calculation.\nReactive values can use either the global singleton or a dedicated instance\n\nsource\n\n\n\n RModel ()\n\nReactive model defines global calculation timer\n\nsource\n\n\n\n\n RModel.step ()\n\nIncreases the timestep of the reactive model\nWe also have a global variable singleton_model to represent a global singleton.",
    "crumbs": [
      "reactive"
    ]
  },
  {
    "objectID": "reactive.html#basic-primitives",
    "href": "reactive.html#basic-primitives",
    "title": "reactive",
    "section": "",
    "text": "source\n\n\n\n RValue (model:__main__.RModel=__main__.RModel(ts=0))\n\nBasic reactive calculation primitive\nThe object represents a cachable reactive value.\nMethod calc() on an object is called whenever a value of the object is needed. The value is cached in an object. The value is automatically invalidated whenever its inputs changes.\n\nsource\n\n\n\n\n RValue.get_dependents ()\n\nReturns all RValues that this calculation depends on\n\nsource\n\n\n\n\n RValue.value ()\n\nReturns value of the RValue object. If the value is outdated, the calc method is automatically called\n\nsource\n\n\n\n\n RValue.is_outdated ()\n\nReturns true if the value changed due to update to dependent inputs\n\nsource\n\n\n\n\n RValue.calc ()\n\nCalculates the value. Must be overriden\n\nsource\n\n\n\n\n RInput (init_value)\n\nRepresents input value to the calculation\nInput values are RValues that can be set using RInput.set_value.\n\nsource\n\n\n\n\n RInput.set_value (value)\n\nSets the value of the RValue object. Any other reactive values that depend on this value are automatically invalidated",
    "crumbs": [
      "reactive"
    ]
  },
  {
    "objectID": "reactive.html#examples",
    "href": "reactive.html#examples",
    "title": "reactive",
    "section": "",
    "text": "Most basic usage of reactive values. Here we create a reactive value with 2 inputs and calculate the result\n\na = RInput(1)\nb = RInput(2)\nclass RCalc(RValue):\n    def __init__(self,a,b): super().__init__(); self.a,self.b = a,b\n    def calc(self):\n        print(\"calculating value c\")\n        return self.a.value + self.b.value\nc= RCalc(a,b)\nc.value\n\ncalculating value c\n\n\n3\n\n\n\nc.value\n\n3\n\n\n\na.set_value(5)\n\n\nc.value\n\ncalculating value c\n\n\n7\n\n\n\n\n\nLet’s make writing calculated values a little bit easier.\n\nsource\n\n\n\n\n rcalc (func)\n\nA decorator for converting a simple function to a reactive value\n\na = RInput(1)\nb = RInput(2)\n\n@rcalc\ndef adder(a,b): return a+b\nc = adder(a,b)\nc.value\n\n3\n\n\n\na.set_value(7)\nc.value\n\n9",
    "crumbs": [
      "reactive"
    ]
  },
  {
    "objectID": "explore.html",
    "href": "explore.html",
    "title": "explore",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport sklearn.datasets as ds\nimport sklearn.model_selection as ms\nimport sklearn.ensemble as en\nfrom sklearn import linear_model\nfrom mana_signals.data import *\n\n\nd=pd.read_csv('../marketdata/20230101.MATIC.csv.gz', compression='gzip');d\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\n\n\n0\nbybit\nMATICUSDT\n1672531202718000\n1672531202789350\n879e0dcd-cee1-5d5d-b031-2c8f18f14d75\nbuy\n0.7580\n2752\n\n\n1\nbybit\nMATICUSDT\n1672531206141000\n1672531206276571\ncf0bdde5-10ad-5cd1-acf4-8ced48b3b5fd\nbuy\n0.7580\n1790\n\n\n2\nbybit\nMATICUSDT\n1672531207221000\n1672531207272223\n814aa74c-3209-501f-9b49-16ae0a3fc930\nsell\n0.7579\n673\n\n\n3\nbybit\nMATICUSDT\n1672531207791000\n1672531207872568\n422980a6-3f9e-5f3b-a514-4c48a14d30c1\nbuy\n0.7580\n21\n\n\n4\nbybit\nMATICUSDT\n1672531211417000\n1672531211472638\n55ac929e-7319-50dc-9853-187297a6289f\nsell\n0.7579\n24998\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n26146\nbybit\nMATICUSDT\n1672617596680000\n1672617596772372\nbc17597e-4144-5f34-9af3-fbf507e88382\nsell\n0.7602\n1289\n\n\n26147\nbybit\nMATICUSDT\n1672617596680000\n1672617596772372\n323b97da-d06a-5403-bbcc-7e6dd9623967\nsell\n0.7602\n3281\n\n\n26148\nbybit\nMATICUSDT\n1672617596725000\n1672617596772372\n746e89ad-ebcb-5cab-8cc6-ad47cefc1771\nsell\n0.7601\n2000\n\n\n26149\nbybit\nMATICUSDT\n1672617597691000\n1672617597772425\nfa978731-8923-5313-b24e-1ce5a523673a\nsell\n0.7600\n1442\n\n\n26150\nbybit\nMATICUSDT\n1672617597691000\n1672617597772425\n1b14a79c-a353-5c01-8063-b46b5bd00ecd\nsell\n0.7600\n227\n\n\n\n\n26151 rows × 8 columns\n\n\n\n\n\nd['date']=pd.to_datetime(d.local_timestamp, unit='us'); \nd.set_index('date', inplace=True);d\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n2023-01-01 00:00:02.789350\nbybit\nMATICUSDT\n1672531202718000\n1672531202789350\n879e0dcd-cee1-5d5d-b031-2c8f18f14d75\nbuy\n0.7580\n2752\n\n\n2023-01-01 00:00:06.276571\nbybit\nMATICUSDT\n1672531206141000\n1672531206276571\ncf0bdde5-10ad-5cd1-acf4-8ced48b3b5fd\nbuy\n0.7580\n1790\n\n\n2023-01-01 00:00:07.272223\nbybit\nMATICUSDT\n1672531207221000\n1672531207272223\n814aa74c-3209-501f-9b49-16ae0a3fc930\nsell\n0.7579\n673\n\n\n2023-01-01 00:00:07.872568\nbybit\nMATICUSDT\n1672531207791000\n1672531207872568\n422980a6-3f9e-5f3b-a514-4c48a14d30c1\nbuy\n0.7580\n21\n\n\n2023-01-01 00:00:11.472638\nbybit\nMATICUSDT\n1672531211417000\n1672531211472638\n55ac929e-7319-50dc-9853-187297a6289f\nsell\n0.7579\n24998\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2023-01-01 23:59:56.772372\nbybit\nMATICUSDT\n1672617596680000\n1672617596772372\nbc17597e-4144-5f34-9af3-fbf507e88382\nsell\n0.7602\n1289\n\n\n2023-01-01 23:59:56.772372\nbybit\nMATICUSDT\n1672617596680000\n1672617596772372\n323b97da-d06a-5403-bbcc-7e6dd9623967\nsell\n0.7602\n3281\n\n\n2023-01-01 23:59:56.772372\nbybit\nMATICUSDT\n1672617596725000\n1672617596772372\n746e89ad-ebcb-5cab-8cc6-ad47cefc1771\nsell\n0.7601\n2000\n\n\n2023-01-01 23:59:57.772425\nbybit\nMATICUSDT\n1672617597691000\n1672617597772425\nfa978731-8923-5313-b24e-1ce5a523673a\nsell\n0.7600\n1442\n\n\n2023-01-01 23:59:57.772425\nbybit\nMATICUSDT\n1672617597691000\n1672617597772425\n1b14a79c-a353-5c01-8063-b46b5bd00ecd\nsell\n0.7600\n227\n\n\n\n\n26151 rows × 8 columns\n\n\n\n\n\nfrom pathlib import Path\nfrom fastcore.all import *\n\n\ndef get_symbols(market_data_path: Path): # Location of marketdata directory\n    \"Returns a list of all symbols available at given market data dump directory\"\n    def extract_symbol(p:Path): \n        return (p.name.split('.')[1])\n    return list(set(map(extract_symbol, market_data_path.ls())))\n\ndef load_symbol(market_data_path: Path, symbol: str): \n    result = None\n    for file in market_data_path.glob(f\"*.{symbol}.csv.gz\"): \n        print(f'processing file {file}')\n        df = pd.read_csv(file, compression=\"gzip\")\n        df['date'] = pd.to_datetime(df.local_timestamp, unit='us')\n        df.set_index('date', inplace=True)\n        result = df if result is None else pd.concat([result,df])\n    return result.sort_index()\n\n\nmarket_data_dir=Path('../marketdata')\nsymbols=get_symbols(market_data_dir); symbols\n\n['MATIC', 'XRP', 'OP']\n\n\n\nloaded_data = dict((sym, load_symbol(market_data_dir, sym)) for sym in symbols)\n\nprocessing file ../marketdata/20230501.MATIC.csv.gz\nprocessing file ../marketdata/20231001.MATIC.csv.gz\nprocessing file ../marketdata/20230201.MATIC.csv.gz\nprocessing file ../marketdata/20230301.MATIC.csv.gz\nprocessing file ../marketdata/20231101.MATIC.csv.gz\nprocessing file ../marketdata/20230401.MATIC.csv.gz\nprocessing file ../marketdata/20230601.MATIC.csv.gz\nprocessing file ../marketdata/20230101.MATIC.csv.gz\nprocessing file ../marketdata/20230901.MATIC.csv.gz\nprocessing file ../marketdata/20230801.MATIC.csv.gz\nprocessing file ../marketdata/20230701.MATIC.csv.gz\nprocessing file ../marketdata/20231201.MATIC.csv.gz\nprocessing file ../marketdata/20230701.XRP.csv.gz\nprocessing file ../marketdata/20231201.XRP.csv.gz\nprocessing file ../marketdata/20230601.XRP.csv.gz\nprocessing file ../marketdata/20230101.XRP.csv.gz\nprocessing file ../marketdata/20231101.XRP.csv.gz\nprocessing file ../marketdata/20230301.XRP.csv.gz\nprocessing file ../marketdata/20230401.XRP.csv.gz\nprocessing file ../marketdata/20230501.XRP.csv.gz\nprocessing file ../marketdata/20230201.XRP.csv.gz\nprocessing file ../marketdata/20231001.XRP.csv.gz\nprocessing file ../marketdata/20230801.XRP.csv.gz\nprocessing file ../marketdata/20230901.XRP.csv.gz\nprocessing file ../marketdata/20230901.OP.csv.gz\nprocessing file ../marketdata/20231001.OP.csv.gz\nprocessing file ../marketdata/20230501.OP.csv.gz\nprocessing file ../marketdata/20230601.OP.csv.gz\nprocessing file ../marketdata/20230301.OP.csv.gz\nprocessing file ../marketdata/20230401.OP.csv.gz\nprocessing file ../marketdata/20231101.OP.csv.gz\nprocessing file ../marketdata/20230801.OP.csv.gz\nprocessing file ../marketdata/20230101.OP.csv.gz\nprocessing file ../marketdata/20230201.OP.csv.gz\nprocessing file ../marketdata/20231201.OP.csv.gz\nprocessing file ../marketdata/20230701.OP.csv.gz\n\n\n\nloaded_data['OP'].shape\n\n(2010003, 8)\n\n\n\nop=loaded_data['OP']; op\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n2023-01-01 00:00:15.722467\nbybit\nOPUSDT\n1672531215663000\n1672531215722467\n52778cfb-e40c-5bfc-a3c2-d2f10330d30c\nbuy\n0.9175\n218.1\n\n\n2023-01-01 00:01:05.022988\nbybit\nOPUSDT\n1672531264958000\n1672531265022988\n978a157d-fd39-5a9e-bf7b-03f5b1ec5e68\nbuy\n0.9175\n11.0\n\n\n2023-01-01 00:01:11.523812\nbybit\nOPUSDT\n1672531271409000\n1672531271523812\nd772dfc0-be35-5315-b48a-eaa6cf278a90\nbuy\n0.9175\n490.4\n\n\n2023-01-01 00:01:11.523812\nbybit\nOPUSDT\n1672531271409000\n1672531271523812\naa52db3b-cbec-5983-b929-a990a4ddb22e\nbuy\n0.9175\n60.8\n\n\n2023-01-01 00:01:11.523812\nbybit\nOPUSDT\n1672531271410000\n1672531271523812\n8b94fb5f-bf11-5ea0-8f3e-e77365b515a1\nbuy\n0.9175\n45.3\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2023-12-01 23:59:28.742716\nbybit\nOPUSDT\n1701475168704000\n1701475168742716\nea55256e-405f-5463-907e-d51692b421e6\nsell\n1.6591\n51.0\n\n\n2023-12-01 23:59:28.743235\nbybit\nOPUSDT\n1701475168704000\n1701475168743235\n9927618c-7d99-5f2a-9219-ce1945d5ee75\nsell\n1.6587\n534.6\n\n\n2023-12-01 23:59:59.327312\nbybit\nOPUSDT\n1701475199288000\n1701475199327312\nea2612e8-a491-51b5-86d5-ab3192004e6a\nsell\n1.6584\n16.9\n\n\n2023-12-01 23:59:59.327312\nbybit\nOPUSDT\n1701475199288000\n1701475199327312\na734b962-cebe-5719-a0da-b6985642ff79\nsell\n1.6584\n1.0\n\n\n2023-12-01 23:59:59.327312\nbybit\nOPUSDT\n1701475199288000\n1701475199327312\n2338b7be-c757-5faf-8c5a-b1f8f290a303\nsell\n1.6584\n47.6\n\n\n\n\n2010003 rows × 8 columns\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\n\nplt.plot(op['price'], marker='o')\n\n\n\n\n\n\n\n\n\ndef get_days_with_data(data): return data.index.normalize().unique().copy().sort_values()\nfor k,v in loaded_data.items(): print (k, get_days_with_data(v))\n\nMATIC DatetimeIndex(['2023-01-01', '2023-02-01', '2023-03-01', '2023-04-01',\n               '2023-05-01', '2023-06-01', '2023-07-01', '2023-08-01',\n               '2023-09-01', '2023-10-01', '2023-11-01', '2023-12-01'],\n              dtype='datetime64[ns]', name='date', freq=None)\nXRP DatetimeIndex(['2023-01-01', '2023-02-01', '2023-03-01', '2023-04-01',\n               '2023-05-01', '2023-06-01', '2023-07-01', '2023-08-01',\n               '2023-09-01', '2023-10-01', '2023-11-01', '2023-12-01'],\n              dtype='datetime64[ns]', name='date', freq=None)\nOP DatetimeIndex(['2023-01-01', '2023-02-01', '2023-03-01', '2023-04-01',\n               '2023-05-01', '2023-06-01', '2023-07-01', '2023-08-01',\n               '2023-09-01', '2023-10-01', '2023-11-01', '2023-12-01'],\n              dtype='datetime64[ns]', name='date', freq=None)\n\n\nBased on above data, we see that we have data for the first day of each month of 2023 for symbols MATIC, XRP, OP.\n\n\nLet’s try to analyze the series 2023-01-01 for OP\n\ndef get_month_data(symbol:str, month:int): \n    d=loaded_data[symbol]\n    return d[d.index.normalize()==pd.to_datetime(f'2023-{month:2}-01')]; \nlen(get_month_data('OP',1))\n\n13126\n\n\n\nd=get_month_data('OP', 1)\nd.index = d.index-d.index[0];\nplt.plot(d.price)\n\n\n\n\n\n\n\n\n\ndef plot_daily_change(d_jan, m):\n    plt.figure(figsize=(15,5));plt.plot(np.log(d_jan.price).diff()); plt.title(f'Movements of OP within a 1st day of month {m}'); plt.grid(True); plt.xticks(rotation=90)\n#for i in range(12): plot_daily_change(get_month_data('OP', i+1), i+1)\n\ndef plot_all_months(symbol): \n    plt.figure(figsize=(15,5))\n    for m in range(12): \n        d = get_month_data(symbol, m+1)\n        d.index = d.index-d.index[0]\n        plt.plot(np.log(d.price).diff(), label=f\"Month {m+1}\")\n    plt.grid(True); plt.xticks(rotation=90)\n    plt.legend()\n    plt.title(f'Symbol {symbol} over the day')\nplot_all_months('OP')\n\n\n\n\n\n\n\n\n\n\nLet’s see if we can predict a value 1 minute ahead\n\nd=get_month_data('OP',1)\nr=d.rolling('1h')\nr[['price', 'amount']]\n\nRolling [window=1h,min_periods=1,center=False,axis=0,method=single]\n\n\n\nv=d.index.values[-1]\nd[(d.index&lt;v) & ((v-d.index)&lt;=np.timedelta64(1,'h'))]\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n2023-01-01 22:58:36.122780\nbybit\nOPUSDT\n1672613916082000\n1672613916122780\n92929f0d-8d9b-5f4f-9470-8a6b833040a5\nsell\n0.9230\n1599.5\n\n\n2023-01-01 22:58:36.122780\nbybit\nOPUSDT\n1672613916082000\n1672613916122780\n2a5f516d-9d55-5068-bc34-116dfaf70254\nsell\n0.9230\n294.9\n\n\n2023-01-01 22:58:47.122591\nbybit\nOPUSDT\n1672613926988000\n1672613927122591\n5142a024-2545-557d-8576-4cf63db92dba\nsell\n0.9230\n34.9\n\n\n2023-01-01 23:00:05.423478\nbybit\nOPUSDT\n1672614005376000\n1672614005423478\n29e21855-46b3-5db9-9cf3-a0e821891d0f\nsell\n0.9230\n590.3\n\n\n2023-01-01 23:00:05.423478\nbybit\nOPUSDT\n1672614005376000\n1672614005423478\n54fb0eb4-e614-504e-ac7e-51737f630e54\nsell\n0.9230\n1772.1\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2023-01-01 23:57:08.524573\nbybit\nOPUSDT\n1672617428476000\n1672617428524573\n1a5d5381-01fa-5230-acd0-0e85be3ca653\nbuy\n0.9240\n33.1\n\n\n2023-01-01 23:57:36.423056\nbybit\nOPUSDT\n1672617456359000\n1672617456423056\n6bfdc66f-016e-5f8f-a1d7-6b530285cf85\nsell\n0.9235\n8046.8\n\n\n2023-01-01 23:57:36.423056\nbybit\nOPUSDT\n1672617456369000\n1672617456423056\na9f3fb3c-8020-55c0-80fe-5986e271476d\nsell\n0.9235\n1173.4\n\n\n2023-01-01 23:57:45.522253\nbybit\nOPUSDT\n1672617465419000\n1672617465522253\nbad6c87a-09b8-5530-95bd-1643cef138c8\nbuy\n0.9235\n277.9\n\n\n2023-01-01 23:58:15.122420\nbybit\nOPUSDT\n1672617494991000\n1672617495122420\n2da38b8d-a3df-57c6-ba72-ecb8e5ee9f2e\nbuy\n0.9230\n5.0\n\n\n\n\n553 rows × 8 columns",
    "crumbs": [
      "explore"
    ]
  },
  {
    "objectID": "dask.html",
    "href": "dask.html",
    "title": "dask",
    "section": "",
    "text": "Exploring distributed computation using dask platform.\nDask (https://www.dask.org) seems to be an easy approach how to scale up the calculation that are done using pytorch and numpy.\nDask has a similar interface as numpy and torch. Dask breaks up large data frames into sections and calculations are automatically distributed across many procesess.\n\n\n\nRequirement already satisfied: dask[complete] in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (2024.2.1)\nRequirement already satisfied: click&gt;=8.1 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (8.1.7)\nRequirement already satisfied: cloudpickle&gt;=1.5.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (3.0.0)\nRequirement already satisfied: fsspec&gt;=2021.09.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (2024.2.0)\nRequirement already satisfied: packaging&gt;=20.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (23.2)\nRequirement already satisfied: partd&gt;=1.2.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (1.4.1)\nRequirement already satisfied: pyyaml&gt;=5.3.1 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (6.0.1)\nRequirement already satisfied: toolz&gt;=0.10.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (0.12.1)\nRequirement already satisfied: importlib-metadata&gt;=4.13.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (7.0.1)\nRequirement already satisfied: pyarrow&gt;=7.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (15.0.0)\nRequirement already satisfied: pyarrow-hotfix in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (0.6)\nRequirement already satisfied: lz4&gt;=4.3.2 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (4.3.3)\nRequirement already satisfied: zipp&gt;=0.5 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from importlib-metadata&gt;=4.13.0-&gt;dask[complete]) (3.17.0)\nRequirement already satisfied: locket in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from partd&gt;=1.2.0-&gt;dask[complete]) (1.0.0)\nRequirement already satisfied: numpy&lt;2,&gt;=1.16.6 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from pyarrow&gt;=7.0-&gt;dask[complete]) (1.26.4)\nRequirement already satisfied: pandas&gt;=1.3 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (2.2.1)\nRequirement already satisfied: bokeh&gt;=2.4.2 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (3.3.4)\nRequirement already satisfied: jinja2&gt;=2.10.3 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (3.1.3)\nRequirement already satisfied: distributed==2024.2.1 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from dask[complete]) (2024.2.1)\nRequirement already satisfied: msgpack&gt;=1.0.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from distributed==2024.2.1-&gt;dask[complete]) (1.0.8)\nRequirement already satisfied: psutil&gt;=5.7.2 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from distributed==2024.2.1-&gt;dask[complete]) (5.9.8)\nRequirement already satisfied: sortedcontainers&gt;=2.0.5 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from distributed==2024.2.1-&gt;dask[complete]) (2.4.0)\nRequirement already satisfied: tblib&gt;=1.6.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from distributed==2024.2.1-&gt;dask[complete]) (3.0.0)\nRequirement already satisfied: tornado&gt;=6.0.4 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from distributed==2024.2.1-&gt;dask[complete]) (6.4)\nRequirement already satisfied: urllib3&gt;=1.24.3 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from distributed==2024.2.1-&gt;dask[complete]) (2.2.1)\nRequirement already satisfied: zict&gt;=3.0.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from distributed==2024.2.1-&gt;dask[complete]) (3.0.0)\nRequirement already satisfied: contourpy&gt;=1 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from bokeh&gt;=2.4.2-&gt;dask[complete]) (1.2.0)\nRequirement already satisfied: pillow&gt;=7.1.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from bokeh&gt;=2.4.2-&gt;dask[complete]) (10.2.0)\nRequirement already satisfied: xyzservices&gt;=2021.09.1 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from bokeh&gt;=2.4.2-&gt;dask[complete]) (2023.10.1)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from jinja2&gt;=2.10.3-&gt;dask[complete]) (2.1.5)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from pandas&gt;=1.3-&gt;dask[complete]) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from pandas&gt;=1.3-&gt;dask[complete]) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from pandas&gt;=1.3-&gt;dask[complete]) (2024.1)\nRequirement already satisfied: six&gt;=1.5 in /Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas&gt;=1.3-&gt;dask[complete]) (1.16.0)\n\n[notice] A new release of pip is available: 23.2.1 -&gt; 24.0\n[notice] To update, run: pip install --upgrade pip\nNote: you may need to restart the kernel to use updated packages.\n\n\n\nClinet\nThis is the root of our distributed computation\n\nfrom dask.distributed import Client, progress\nclient = Client(processes=False, threads_per_worker=4,\n                n_workers=1, memory_limit='2GB')\nclient\n\n/Users/jstranik/Developer/manafund/mana-signals/.venv/lib/python3.11/site-packages/distributed/node.py:182: UserWarning: Port 8787 is already in use.\nPerhaps you already have a cluster running?\nHosting the HTTP server on port 50914 instead\n  warnings.warn(\n2024-03-05 16:16:32,954 - distributed.scheduler - ERROR - Couldn't gather keys: {('sum-aggregate-2151311f9cb12b4138e475aa03fb945e',): 'waiting'}\n2024-03-05 16:16:33,348 - distributed.scheduler - ERROR - Couldn't gather keys: {('sum-aggregate-2151311f9cb12b4138e475aa03fb945e',): 'waiting'}\n2024-03-05 16:16:34,255 - distributed.scheduler - ERROR - Couldn't gather keys: {('sum-aggregate-2151311f9cb12b4138e475aa03fb945e',): 'waiting'}\n2024-03-06 07:39:33,252 - distributed.scheduler - WARNING - Worker failed to heartbeat within 300 seconds. Closing: &lt;WorkerState 'inproc://192.168.1.94/93407/13', name: 0, status: running, memory: 100, processing: 0&gt;\n2024-03-06 07:39:33,356 - distributed.scheduler - WARNING - Received heartbeat from unregistered worker 'inproc://192.168.1.94/93407/13'.\n2024-03-06 07:39:33,358 - distributed.worker - WARNING - Scheduler was unaware of this worker; shutting down.\n\n\n\n\n     \n    \n        Client\n        Client-a3bb19d6-db35-11ee-acdf-d652af080e39\n        \n\n\n\nConnection method: Cluster object\nCluster type: distributed.LocalCluster\n\n\nDashboard: http://192.168.1.94:50914/status\n\n\n\n\n\n\n\nCluster Info\n\n\n\n\n\n\n\nLocalCluster\ncc1e5ef4\n\n\n\nDashboard: http://192.168.1.94:50914/status\nWorkers: 1\n\n\nTotal threads: 4\nTotal memory: 1.86 GiB\n\n\nStatus: running\nUsing processes: False\n\n\n\n\n\n\n\nScheduler Info\n\n\n\n\n\n\n\nScheduler\nScheduler-269515e6-4a8c-4c54-a4f3-99804d27cf84\n\n\n\nComm: inproc://192.168.1.94/93407/10\nWorkers: 1\n\n\nDashboard: http://192.168.1.94:50914/status\nTotal threads: 4\n\n\nStarted: Just now\nTotal memory: 1.86 GiB\n\n\n\n\n\n\n\n\nWorkers\n\n\n\n\n\n\n\n\n\nWorker: 0\n\n\n\n\nComm: inproc://192.168.1.94/93407/13\nTotal threads: 4\n\n\nDashboard: http://192.168.1.94:50915/status\nMemory: 1.86 GiB\n\n\nNanny: None\n\n\n\nLocal directory: /var/folders/l_/l7636tpj5zzd5cx3pwzdd8k00000gn/T/dask-scratch-space/worker-ipr2u5ot",
    "crumbs": [
      "dask"
    ]
  },
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "demo",
    "section": "",
    "text": "We will design a system that consumes market data. The market data is processed and sybmol ticks are pushed to the system.\nThe system will process data and calculate a volatility of market. Volatility of the market is defined as a mean volatility across the price volatility of individual symbols.\nWe define a volatility of symbol as a standard deviation of last 20 trades in log scale.\n\nsource\n\nRVolCalculator\n\n RVolCalculator (priceInput:mana_signals.reactive.RValue)\n\nVol calculator for given price input.\nCalculates vol of last 20 price ticks for a given input.\n\nsource\n\n\nRMarketVol\n\n RMarketVol (symbol_prices:List[mana_signals.reactive.RValue])\n\ncalculates average volatility of the given price inputs\n\nsource\n\n\nExecEngine\n\n ExecEngine ()\n\nExecution engine for the market\n\n\nSimple Exec Engine\n\nengine = ExecEngine()\nengine.load_market_data_files([Path('../marketdata/20230101.MATIC.csv.gz')])\n\n\nengine.market_data.index\n\nDatetimeIndex(['2023-01-01 00:00:02.789350', '2023-01-01 00:00:06.276571',\n               '2023-01-01 00:00:07.272223', '2023-01-01 00:00:07.872568',\n               '2023-01-01 00:00:11.472638', '2023-01-01 00:00:11.472638',\n               '2023-01-01 00:00:11.472638', '2023-01-01 00:00:11.472638',\n               '2023-01-01 00:00:11.472638', '2023-01-01 00:00:11.472638',\n               ...\n               '2023-01-01 23:59:10.772233', '2023-01-01 23:59:29.672451',\n               '2023-01-01 23:59:29.672451', '2023-01-01 23:59:29.672451',\n               '2023-01-01 23:59:56.772372', '2023-01-01 23:59:56.772372',\n               '2023-01-01 23:59:56.772372', '2023-01-01 23:59:56.772372',\n               '2023-01-01 23:59:57.772425', '2023-01-01 23:59:57.772425'],\n              dtype='datetime64[ns]', name='date', length=26151, freq=None)\n\n\n\n\nVolSignalEngine\n\nsource\n\nSignalEngine\n\n SignalEngine ()\n\nExecution engine for the market\n\nengine = SignalEngine()\n\n\nengine.load_market_data_files(['../marketdata/20230101.MATIC.csv.gz'])\n\n\nengine.run()\n\n/var/folders/l_/l7636tpj5zzd5cx3pwzdd8k00000gn/T/ipykernel_29920/1427249217.py:11: RuntimeWarning: Mean of empty slice\n  return np.nanmean(vols)\n\n\n\nengine.result[-10:]\n\n['2023-01-01 23:59:10.772233, 6.0864435782985807e-05',\n '2023-01-01 23:59:29.672451, 5.472028913292919e-05',\n '2023-01-01 23:59:29.672451, 4.7112437455448106e-05',\n '2023-01-01 23:59:29.672451, 4.4377844789784614e-05',\n '2023-01-01 23:59:56.772372, 5.042174862790632e-05',\n '2023-01-01 23:59:56.772372, 5.56702216927174e-05',\n '2023-01-01 23:59:56.772372, 6.19808456245811e-05',\n '2023-01-01 23:59:56.772372, 6.3460650664703e-05',\n '2023-01-01 23:59:57.772425, 6.224075795312596e-05',\n '2023-01-01 23:59:57.772425, 6.086400637705373e-05']\n\n\nAnd we got results collected to the output\n\n\n\nCommand line utility for real time processing\nFor the demo, we also create a command line utility for processing data\nInvocation:\n\nsimulate_signal_processing –data ./marketdata/20230101.MATIC.csv.gz\n\n\nsource\n\nSignalEngineLive\n\n SignalEngineLive ()\n\nExecution engine for the market\n\nengine = SignalEngineLive()\nengine.load_market_data_files(['../marketdata/20230101.MATIC.csv.gz'])\nengine.run()\n\n/var/folders/l_/l7636tpj5zzd5cx3pwzdd8k00000gn/T/ipykernel_29920/1427249217.py:11: RuntimeWarning: Mean of empty slice\n  return np.nanmean(vols)\n\n\n\nsource\n\n\nsimulate_signal_processing\n\n simulate_signal_processing ()\n\nScript entry point for signal processing",
    "crumbs": [
      "demo"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nRDelay\n\n RDelay (source:mana_signals.reactive.RValue, delay_n:int=1)\n\nValue shifted from the calculation by given delay\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsource\nRValue\n\nsource value\n\n\ndelay_n\nint\n1\namount of shift\n\n\n\nExample of using shifted reactive value\n\na = RInput(0)\nv = RDelay(a, delay_n=1)\nprint(v.value)\na.set_value(8);print(v.value)\na.set_value(1);print(v.value)\n\nnan\n0.0\n8.0\n\n\n\na=np.array([1,2,3])\nnp.roll(a, shift=1)\n\narray([3, 1, 2])\n\n\n\nsource\n\n\nRLastn\n\n RLastn (source:mana_signals.reactive.RValue, n:int=1, missing_val=nan)\n\nLast n values collected from the given source\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsource\nRValue\n\nsource value\n\n\nn\nint\n1\nnumber of values to collect\n\n\nmissing_val\nfloat\nnan\nfiller value for missing data\n\n\n\n\na = RInput(0)\nv = RLastn(a, 3)\nfor i in range(5): \n    print(v.value)\n    a.set_value(i)\n\n[ 0. nan nan]\n[ 0.  0. nan]\n[1. 0. 0.]\n[2. 1. 0.]\n[3. 2. 1.]\n\n\n\nsource\n\n\nRMean\n\n RMean (source:mana_signals.reactive.RValue, n:int)\n\nCalculates mean of the last n values\n\n\n\n\nType\nDetails\n\n\n\n\nsource\nRValue\nsource value\n\n\nn\nint\nnumber of values to calculate the mean\n\n\n\n\na = RInput(0)\nv = RMean(a, 3)\nfor i in range(5): \n    print(v.value, v.last.value)\n    a.set_value(i+1)\n\nnan [ 0. nan nan]\nnan [ 1.  0. nan]\n1.0 [2. 1. 0.]\n2.0 [3. 2. 1.]\n3.0 [4. 3. 2.]\n\n\n\nsource\n\n\nRLinRegression\n\n RLinRegression (xs:mana_signals.reactive.RValue,\n                 ys:mana_signals.reactive.RValue)\n\nCalculates linear regression for the source xs and ys should be of the same length.\n\n\n\n\nType\nDetails\n\n\n\n\nxs\nRValue\nxs independent values\n\n\nys\nRValue\nys dependent values\n\n\n\n\nsource\n\n\nRLinRegression.predict\n\n RLinRegression.predict (x)\n\nGiven x, predicts next value y based on linear regression\n\nxs=np.array([1,2,3]).reshape(-1,1)\nys=np.array([0,5,4])\nreg = linear_model.LinearRegression()\nreg.fit(xs,ys)\nreg.coef_, reg.predict(np.array([[5]]))\n\n(array([2.]), array([9.]))",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "data",
    "section": "",
    "text": "source\n\n\n\n load_market_data_file (market_data_file:pathlib.Path)\n\nLoads a single market data file\n\n\n\n\nType\nDetails\n\n\n\n\nmarket_data_file\nPath\ncsv file to laod data from\n\n\nReturns\nDataFrame\ndata frame with transactions\n\n\n\n\nsource\n\n\n\n\n get_symbols (market_data_path:pathlib.Path)\n\nReturns a list of all symbols available at given market data dump directory\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmarket_data_path\nPath\ndirectory with market data\n\n\nReturns\ntyping.List[str]\nList of symbols that have market data available\n\n\n\n\nsource\n\n\n\n\n load_all_market_data_files_for_symbol (market_data_path:pathlib.Path,\n                                        symbol:str)\n\nLoads all data for the given symbol\n\n\n\n\nType\nDetails\n\n\n\n\nmarket_data_path\nPath\ndirectory with market data\n\n\nsymbol\nstr\nname of the symbol\n\n\nReturns\nDataFrame\ndataframe with transactions\n\n\n\n\nsource\n\n\n\n\n make_sequential_stream (data_frames:List[pandas.core.frame.DataFrame])\n\nTakes a dictionary of data frames and merges them together according to the timestamps (index).\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndata_frames\ntyping.List[pandas.core.frame.DataFrame]\nframes with transacations\n\n\nReturns\nDataFrame\nsequential streamX\n\n\n\n\n\n\n\nmarket_data_dir=Path('../marketdata')\nsymbols=get_symbols(market_data_dir); symbols\n\n['MATIC', 'OP', 'XRP']\n\n\n\nloaded_data = dict((sym, load_all_market_data_files_for_symbol(market_data_dir, sym)) for sym in symbols)\n\nprocessing file ../marketdata/20230501.MATIC.csv.gz\nprocessing file ../marketdata/20231001.MATIC.csv.gz\nprocessing file ../marketdata/20230201.MATIC.csv.gz\nprocessing file ../marketdata/20230301.MATIC.csv.gz\nprocessing file ../marketdata/20231101.MATIC.csv.gz\nprocessing file ../marketdata/20230401.MATIC.csv.gz\nprocessing file ../marketdata/20230601.MATIC.csv.gz\nprocessing file ../marketdata/20230101.MATIC.csv.gz\nprocessing file ../marketdata/20230901.MATIC.csv.gz\nprocessing file ../marketdata/20230801.MATIC.csv.gz\nprocessing file ../marketdata/20230701.MATIC.csv.gz\nprocessing file ../marketdata/20231201.MATIC.csv.gz\nprocessing file ../marketdata/20230901.OP.csv.gz\nprocessing file ../marketdata/20231001.OP.csv.gz\nprocessing file ../marketdata/20230501.OP.csv.gz\nprocessing file ../marketdata/20230601.OP.csv.gz\nprocessing file ../marketdata/20230301.OP.csv.gz\nprocessing file ../marketdata/20230401.OP.csv.gz\nprocessing file ../marketdata/20231101.OP.csv.gz\nprocessing file ../marketdata/20230801.OP.csv.gz\nprocessing file ../marketdata/20230101.OP.csv.gz\nprocessing file ../marketdata/20230201.OP.csv.gz\nprocessing file ../marketdata/20231201.OP.csv.gz\nprocessing file ../marketdata/20230701.OP.csv.gz\nprocessing file ../marketdata/20230701.XRP.csv.gz\nprocessing file ../marketdata/20231201.XRP.csv.gz\nprocessing file ../marketdata/20230601.XRP.csv.gz\nprocessing file ../marketdata/20230101.XRP.csv.gz\nprocessing file ../marketdata/20231101.XRP.csv.gz\nprocessing file ../marketdata/20230301.XRP.csv.gz\nprocessing file ../marketdata/20230401.XRP.csv.gz\nprocessing file ../marketdata/20230501.XRP.csv.gz\nprocessing file ../marketdata/20230201.XRP.csv.gz\nprocessing file ../marketdata/20231001.XRP.csv.gz\nprocessing file ../marketdata/20230801.XRP.csv.gz\nprocessing file ../marketdata/20230901.XRP.csv.gz\n\n\n\nloaded_data['MATIC'].head()\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n2023-01-01 00:00:02.789350\nbybit\nMATICUSDT\n1672531202718000\n1672531202789350\n879e0dcd-cee1-5d5d-b031-2c8f18f14d75\nbuy\n0.7580\n2752\n\n\n2023-01-01 00:00:06.276571\nbybit\nMATICUSDT\n1672531206141000\n1672531206276571\ncf0bdde5-10ad-5cd1-acf4-8ced48b3b5fd\nbuy\n0.7580\n1790\n\n\n2023-01-01 00:00:07.272223\nbybit\nMATICUSDT\n1672531207221000\n1672531207272223\n814aa74c-3209-501f-9b49-16ae0a3fc930\nsell\n0.7579\n673\n\n\n2023-01-01 00:00:07.872568\nbybit\nMATICUSDT\n1672531207791000\n1672531207872568\n422980a6-3f9e-5f3b-a514-4c48a14d30c1\nbuy\n0.7580\n21\n\n\n2023-01-01 00:00:11.472638\nbybit\nMATICUSDT\n1672531211418000\n1672531211472638\nb27b754d-d32d-533d-9d54-a5ab81559f29\nsell\n0.7579\n279\n\n\n\n\n\n\n\n\n\nd = make_sequential_stream(loaded_data.values())\n\nHere we have merged all individual symbol data into a single data frame.\nThe data frame can be used as a “market feed” to the market engine.\n\nd.head(10)\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n2023-01-01 00:00:01.916181\nbybit\nXRPUSDT\n1672531201785000\n1672531201916181\nfc9b084c-f895-502d-b69d-d0912173d089\nbuy\n0.3391\n1.0\n\n\n2023-01-01 00:00:01.916181\nbybit\nXRPUSDT\n1672531201785000\n1672531201916181\nf2ee430c-9576-5bcf-aac6-5243292797ac\nbuy\n0.3391\n2.0\n\n\n2023-01-01 00:00:01.916181\nbybit\nXRPUSDT\n1672531201785000\n1672531201916181\n869f353f-af7d-51f5-ae85-4c006f5322b7\nbuy\n0.3391\n1458.0\n\n\n2023-01-01 00:00:02.215099\nbybit\nXRPUSDT\n1672531202078000\n1672531202215099\n9da1a13d-de98-570c-a070-ff97a3549058\nsell\n0.3390\n1.0\n\n\n2023-01-01 00:00:02.315516\nbybit\nXRPUSDT\n1672531202240000\n1672531202315516\n74cc44d2-8625-5530-ba3e-8c1f823c98db\nsell\n0.3390\n80.0\n\n\n2023-01-01 00:00:02.618189\nbybit\nXRPUSDT\n1672531202534000\n1672531202618189\n0987dc83-a13c-514c-8877-123a2441c2f4\nsell\n0.3390\n70.0\n\n\n2023-01-01 00:00:02.789350\nbybit\nMATICUSDT\n1672531202718000\n1672531202789350\n879e0dcd-cee1-5d5d-b031-2c8f18f14d75\nbuy\n0.7580\n2752.0\n\n\n2023-01-01 00:00:03.417761\nbybit\nXRPUSDT\n1672531203361000\n1672531203417761\n2383e7c1-c42f-5193-b8b7-a9e53cd197f6\nsell\n0.3390\n132.0\n\n\n2023-01-01 00:00:03.515103\nbybit\nXRPUSDT\n1672531203456000\n1672531203515103\n6dff80b1-3ba6-5d44-82fa-9be768300661\nsell\n0.3390\n110.0\n\n\n2023-01-01 00:00:04.114629\nbybit\nXRPUSDT\n1672531204030000\n1672531204114629\n22f32e05-fa32-5dd5-bc55-1fd0ac4a284b\nsell\n0.3390\n1179.0\n\n\n\n\n\n\n\n\n\nlen(d)\n\n6548374\n\n\nWe have about 6m of data points\n\nd['symbol']\n\ndate\n2023-01-01 00:00:01.916181    XRPUSDT\n2023-01-01 00:00:01.916181    XRPUSDT\n2023-01-01 00:00:01.916181    XRPUSDT\n2023-01-01 00:00:02.215099    XRPUSDT\n2023-01-01 00:00:02.315516    XRPUSDT\n                               ...   \n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.565317    XRPUSDT\nName: symbol, Length: 6548374, dtype: object\n\n\n… across 3 symbols.",
    "crumbs": [
      "data"
    ]
  },
  {
    "objectID": "data.html#examples-of-how-data-is-processed",
    "href": "data.html#examples-of-how-data-is-processed",
    "title": "data",
    "section": "",
    "text": "market_data_dir=Path('../marketdata')\nsymbols=get_symbols(market_data_dir); symbols\n\n['MATIC', 'OP', 'XRP']\n\n\n\nloaded_data = dict((sym, load_all_market_data_files_for_symbol(market_data_dir, sym)) for sym in symbols)\n\nprocessing file ../marketdata/20230501.MATIC.csv.gz\nprocessing file ../marketdata/20231001.MATIC.csv.gz\nprocessing file ../marketdata/20230201.MATIC.csv.gz\nprocessing file ../marketdata/20230301.MATIC.csv.gz\nprocessing file ../marketdata/20231101.MATIC.csv.gz\nprocessing file ../marketdata/20230401.MATIC.csv.gz\nprocessing file ../marketdata/20230601.MATIC.csv.gz\nprocessing file ../marketdata/20230101.MATIC.csv.gz\nprocessing file ../marketdata/20230901.MATIC.csv.gz\nprocessing file ../marketdata/20230801.MATIC.csv.gz\nprocessing file ../marketdata/20230701.MATIC.csv.gz\nprocessing file ../marketdata/20231201.MATIC.csv.gz\nprocessing file ../marketdata/20230901.OP.csv.gz\nprocessing file ../marketdata/20231001.OP.csv.gz\nprocessing file ../marketdata/20230501.OP.csv.gz\nprocessing file ../marketdata/20230601.OP.csv.gz\nprocessing file ../marketdata/20230301.OP.csv.gz\nprocessing file ../marketdata/20230401.OP.csv.gz\nprocessing file ../marketdata/20231101.OP.csv.gz\nprocessing file ../marketdata/20230801.OP.csv.gz\nprocessing file ../marketdata/20230101.OP.csv.gz\nprocessing file ../marketdata/20230201.OP.csv.gz\nprocessing file ../marketdata/20231201.OP.csv.gz\nprocessing file ../marketdata/20230701.OP.csv.gz\nprocessing file ../marketdata/20230701.XRP.csv.gz\nprocessing file ../marketdata/20231201.XRP.csv.gz\nprocessing file ../marketdata/20230601.XRP.csv.gz\nprocessing file ../marketdata/20230101.XRP.csv.gz\nprocessing file ../marketdata/20231101.XRP.csv.gz\nprocessing file ../marketdata/20230301.XRP.csv.gz\nprocessing file ../marketdata/20230401.XRP.csv.gz\nprocessing file ../marketdata/20230501.XRP.csv.gz\nprocessing file ../marketdata/20230201.XRP.csv.gz\nprocessing file ../marketdata/20231001.XRP.csv.gz\nprocessing file ../marketdata/20230801.XRP.csv.gz\nprocessing file ../marketdata/20230901.XRP.csv.gz\n\n\n\nloaded_data['MATIC'].head()\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n2023-01-01 00:00:02.789350\nbybit\nMATICUSDT\n1672531202718000\n1672531202789350\n879e0dcd-cee1-5d5d-b031-2c8f18f14d75\nbuy\n0.7580\n2752\n\n\n2023-01-01 00:00:06.276571\nbybit\nMATICUSDT\n1672531206141000\n1672531206276571\ncf0bdde5-10ad-5cd1-acf4-8ced48b3b5fd\nbuy\n0.7580\n1790\n\n\n2023-01-01 00:00:07.272223\nbybit\nMATICUSDT\n1672531207221000\n1672531207272223\n814aa74c-3209-501f-9b49-16ae0a3fc930\nsell\n0.7579\n673\n\n\n2023-01-01 00:00:07.872568\nbybit\nMATICUSDT\n1672531207791000\n1672531207872568\n422980a6-3f9e-5f3b-a514-4c48a14d30c1\nbuy\n0.7580\n21\n\n\n2023-01-01 00:00:11.472638\nbybit\nMATICUSDT\n1672531211418000\n1672531211472638\nb27b754d-d32d-533d-9d54-a5ab81559f29\nsell\n0.7579\n279\n\n\n\n\n\n\n\n\n\nd = make_sequential_stream(loaded_data.values())\n\nHere we have merged all individual symbol data into a single data frame.\nThe data frame can be used as a “market feed” to the market engine.\n\nd.head(10)\n\n\n\n\n\n\n\n\n\nexchange\nsymbol\ntimestamp\nlocal_timestamp\nid\nside\nprice\namount\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n\n\n2023-01-01 00:00:01.916181\nbybit\nXRPUSDT\n1672531201785000\n1672531201916181\nfc9b084c-f895-502d-b69d-d0912173d089\nbuy\n0.3391\n1.0\n\n\n2023-01-01 00:00:01.916181\nbybit\nXRPUSDT\n1672531201785000\n1672531201916181\nf2ee430c-9576-5bcf-aac6-5243292797ac\nbuy\n0.3391\n2.0\n\n\n2023-01-01 00:00:01.916181\nbybit\nXRPUSDT\n1672531201785000\n1672531201916181\n869f353f-af7d-51f5-ae85-4c006f5322b7\nbuy\n0.3391\n1458.0\n\n\n2023-01-01 00:00:02.215099\nbybit\nXRPUSDT\n1672531202078000\n1672531202215099\n9da1a13d-de98-570c-a070-ff97a3549058\nsell\n0.3390\n1.0\n\n\n2023-01-01 00:00:02.315516\nbybit\nXRPUSDT\n1672531202240000\n1672531202315516\n74cc44d2-8625-5530-ba3e-8c1f823c98db\nsell\n0.3390\n80.0\n\n\n2023-01-01 00:00:02.618189\nbybit\nXRPUSDT\n1672531202534000\n1672531202618189\n0987dc83-a13c-514c-8877-123a2441c2f4\nsell\n0.3390\n70.0\n\n\n2023-01-01 00:00:02.789350\nbybit\nMATICUSDT\n1672531202718000\n1672531202789350\n879e0dcd-cee1-5d5d-b031-2c8f18f14d75\nbuy\n0.7580\n2752.0\n\n\n2023-01-01 00:00:03.417761\nbybit\nXRPUSDT\n1672531203361000\n1672531203417761\n2383e7c1-c42f-5193-b8b7-a9e53cd197f6\nsell\n0.3390\n132.0\n\n\n2023-01-01 00:00:03.515103\nbybit\nXRPUSDT\n1672531203456000\n1672531203515103\n6dff80b1-3ba6-5d44-82fa-9be768300661\nsell\n0.3390\n110.0\n\n\n2023-01-01 00:00:04.114629\nbybit\nXRPUSDT\n1672531204030000\n1672531204114629\n22f32e05-fa32-5dd5-bc55-1fd0ac4a284b\nsell\n0.3390\n1179.0\n\n\n\n\n\n\n\n\n\nlen(d)\n\n6548374\n\n\nWe have about 6m of data points\n\nd['symbol']\n\ndate\n2023-01-01 00:00:01.916181    XRPUSDT\n2023-01-01 00:00:01.916181    XRPUSDT\n2023-01-01 00:00:01.916181    XRPUSDT\n2023-01-01 00:00:02.215099    XRPUSDT\n2023-01-01 00:00:02.315516    XRPUSDT\n                               ...   \n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.538142    XRPUSDT\n2023-12-01 23:59:59.565317    XRPUSDT\nName: symbol, Length: 6548374, dtype: object\n\n\n… across 3 symbols.",
    "crumbs": [
      "data"
    ]
  }
]